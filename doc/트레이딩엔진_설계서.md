# 트레이딩 엔진 설계서

> **버전**: v1.0
> **작성일**: 2026-02-16
> **서비스**: trading-service (port 8083)

---

## 1. 개요

### 1.1 목적

모의 주식 게임의 핵심 엔진으로, 실시간 주문 접수·매칭·체결을 처리한다. 사용자(플레이어)와 NPC(개인/기관 투자자)의 주문을 동일한 파이프라인으로 처리하며, 이벤트 기반으로 타 서비스와 연동한다.

### 1.2 핵심 설계 결정

| 항목 | 결정 | 근거 |
|------|------|------|
| 매칭 방식 | 실시간 연속 매칭 | 주문 즉시 처리, 게임 몰입감 |
| 주문 유형 | 지정가(LIMIT) + 시장가(MARKET) | 기본적인 주문 유형 지원 |
| 동시성 모델 | 종목별 단일 스레드 매칭 | 호가창 일관성 보장, 락 불필요 |
| 처리 패턴 | 동기 매칭 + 비동기 후처리 | 매칭 정확성 + 이벤트 발행 분리 |
| 잔고 관리 | 가용/동결 분리 | 주문 시 즉시 동결, 이중 사용 방지 |
| 호가창 저장 | In-memory TreeMap + Redis 영속화 | 매칭 성능 + 장애 복구 |

### 1.3 게임 시간 체계

```
현실:게임 = 1:4
장 운영: 게임 09:00 ~ 21:00 (12시간) = 현실 3시간
1일 사이클: 현실 6시간 = 게임 24시간
하루 8 거래 사이클 (24/7 서버)
```

- `GameTimeUtil.isMarketOpen()`: 장 시간 확인
- 장외 시간에는 주문 접수 거부

---

## 2. 주문 흐름

### 2.1 전체 흐름

```
┌─────────┐     ┌─────────────┐     ┌──────────────┐     ┌───────────┐
│  Client  │────▶│  WebAdapter │────▶│ CommandHandler│────▶│ OrderBook │
│(User/NPC)│     │ POST /orders│     │              │     │  매칭 엔진 │
└─────────┘     └─────────────┘     └──────┬───────┘     └─────┬─────┘
                                           │                    │
                    ┌──────────────────────┘                    │
                    ▼                                           ▼
              ┌───────────┐                           ┌──────────────┐
              │ PostgreSQL│                           │ MatchResult[] │
              │ 주문 이력  │                           └──────┬───────┘
              └───────────┘                                   │
                                                              ▼
                                                     ┌──────────────┐
                                                     │    Kafka     │
                                                     │ 비동기 이벤트 │
                                                     └──────────────┘
```

### 2.2 주문 처리 단계

```
1. 요청 수신 (WebAdapter / EventConsumer)
   └─ REST: POST /api/trading/orders
   └─ Kafka: schedule.trade (NPC 주문)

2. 검증 (CommandHandler)
   ├─ 장 시간 확인 (GameTimeUtil.isMarketOpen)
   ├─ 주문 수량 > 0
   ├─ 지정가: 호가 단위 검증 (PriceUtil.isValidPrice)
   └─ 지정가: 가격 제한 범위 검증 (PriceUtil.getPriceLimits)

3. 주문 생성 (Domain)
   └─ OrderModel.create() → PENDING 상태

4. 영속화 (PostgreSQL)
   └─ OrderPersistencePort.save()

5. 매칭 (OrderBook)
   ├─ OrderBookManager.getOrCreate(stockId)
   └─ OrderBook.addOrder() → 자동 매칭 시도
       ├─ 매칭 성공 → MatchResult 리스트 반환
       └─ 매칭 실패 → 호가창에 잔량 등록

6. 후처리
   ├─ 주문 상태 업데이트 (DB)
   ├─ Redis 호가창 스냅샷 저장
   └─ Kafka 이벤트 발행
       ├─ order.matched (체결 시)
       ├─ price.updated (체결 시)
       └─ orderbook.updated
```

### 2.3 주문 취소 흐름

```
1. DELETE /api/trading/orders/{orderId}
2. 주문 조회 (DB) → 취소 가능 상태 확인
3. OrderBook.cancelOrder(orderId) → 호가창에서 제거
4. 주문 상태 → CANCELLED (DB)
5. 동결 잔고 해제 (TODO: balance-service 연동)
6. Kafka: order.cancelled
```

---

## 3. 호가창 (Order Book)

### 3.1 자료구조

```kotlin
class OrderBook(val stockId: String) {
    // 매수 호가: 높은 가격 우선 (reverseOrder)
    private val bids: TreeMap<Long, MutableList<OrderEntry>> = TreeMap(reverseOrder())

    // 매도 호가: 낮은 가격 우선 (naturalOrder)
    private val asks: TreeMap<Long, MutableList<OrderEntry>> = TreeMap()

    // 주문 ID → OrderEntry 매핑 (취소용 빠른 조회)
    private val orderIndex: MutableMap<String, OrderEntry> = mutableMapOf()
}
```

**설계 근거:**
- `TreeMap`: 가격 레벨 자동 정렬, O(log N) 삽입/조회
- `MutableList<OrderEntry>`: 동일 가격 내 시간 순서 보장 (FIFO)
- `orderIndex`: 취소 시 O(1) 조회

### 3.2 OrderEntry (호가창 내부 VO)

```kotlin
data class OrderEntry(
    val orderId: String,
    val userId: String,
    val price: Long,           // 지정가 (시장가는 매칭 시 상대방 가격 사용)
    var remainingQuantity: Long,
    val timestamp: Instant
)
```

- 매칭에 필요한 **최소 필드**만 보유 (경량)
- `remainingQuantity`만 mutable (부분 체결)

### 3.3 매칭 알고리즘

#### 가격 우선·시간 우선 원칙

```
1차: 가격 우선 (Price Priority)
   - 매수: 높은 가격 우선
   - 매도: 낮은 가격 우선

2차: 시간 우선 (Time Priority)
   - 동일 가격 내 먼저 접수된 주문 우선 (FIFO)
```

#### 매칭 로직 (addOrder)

```
addOrder(entry, orderType, orderKind):
    matches = []

    if orderType == BUY:
        oppositeBook = asks
        canMatch = { askPrice ->
            if MARKET: true (시장가는 무조건 매칭)
            if LIMIT:  askPrice <= entry.price (매도호가 ≤ 매수지정가)
        }
    else: // SELL
        oppositeBook = bids
        canMatch = { bidPrice ->
            if MARKET: true
            if LIMIT:  bidPrice >= entry.price (매수호가 ≥ 매도지정가)
        }

    while entry.remainingQuantity > 0 && oppositeBook.isNotEmpty():
        bestPrice = oppositeBook.firstKey()
        if !canMatch(bestPrice): break

        queue = oppositeBook[bestPrice]
        while queue.isNotEmpty() && entry.remainingQuantity > 0:
            opponent = queue.first()
            matchQty = min(entry.remainingQuantity, opponent.remainingQuantity)
            matchPrice = bestPrice  // 먼저 등록된 쪽의 가격으로 체결

            entry.remainingQuantity -= matchQty
            opponent.remainingQuantity -= matchQty

            if opponent.remainingQuantity == 0:
                queue.removeFirst()
                orderIndex.remove(opponent.orderId)

            matches.add(MatchResult(
                buyOrderId, sellOrderId, 양측 userId,
                stockId, matchPrice, matchQty
            ))

        if queue.isEmpty():
            oppositeBook.remove(bestPrice)

    // 잔량이 있으면 호가창에 등록 (시장가 제외)
    if entry.remainingQuantity > 0 && orderKind == LIMIT:
        myBook[entry.price].add(entry)
        orderIndex[entry.orderId] = entry

    return matches
```

#### 시장가 주문 처리

- 시장가 매수: asks의 최저가부터 순서대로 체결
- 시장가 매도: bids의 최고가부터 순서대로 체결
- 호가창에 상대 주문이 없으면 → 체결 불가, 주문 거부 (시장가는 잔량 등록 안 함)
- 부분 체결 후 잔량도 거부 (시장가는 호가창에 남지 않음)

### 3.4 호가창 스냅샷

```kotlin
data class PriceLevel(
    val price: Long,
    val quantity: Long,      // 해당 가격의 총 수량
    val orderCount: Int      // 해당 가격의 주문 건수
)

data class OrderBookSnapshot(
    val stockId: String,
    val bids: List<PriceLevel>,   // 매수 호가 (높은 가격순)
    val asks: List<PriceLevel>,   // 매도 호가 (낮은 가격순)
    val bestBid: Long?,
    val bestAsk: Long?,
    val spread: Long?,            // bestAsk - bestBid
    val timestamp: Instant
)
```

- `getSnapshot(depth: Int = 10)`: 상위 N개 가격 레벨만 반환
- Kafka `orderbook.updated` 이벤트용 + REST API 응답용

---

## 4. 도메인 모델

### 4.1 OrderModel

```kotlin
data class OrderModel(
    val orderId: String,
    val userId: String,
    val stockId: String,
    val orderType: OrderType,     // BUY, SELL (common Enum 재사용)
    val orderKind: OrderKind,     // LIMIT, MARKET (신규 enum)
    val price: Long?,             // null = 시장가
    val quantity: Long,
    val filledQuantity: Long,
    val status: OrderStatus,      // common Enum 재사용
    val createdAt: Instant,
    val updatedAt: Instant
)
```

**주요 메서드:**

| 메서드 | 설명 |
|--------|------|
| `create(userId, stockId, orderType, orderKind, price, quantity)` | 팩토리. UUID 생성, PENDING 상태 |
| `of(...)` | DB 복원용 팩토리 |
| `fill(matchedQuantity)` | 체결 처리. filledQuantity 누적, 상태 전이 (PARTIALLY_FILLED / FILLED) |
| `cancel()` | 취소. PENDING/PARTIALLY_FILLED → CANCELLED |
| `remainingQuantity` | `quantity - filledQuantity` (computed property) |

**init 검증:**
- `quantity > 0`
- `filledQuantity >= 0 && filledQuantity <= quantity`
- `orderKind == LIMIT → price != null && price > 0`
- `orderKind == MARKET → price == null`

**OrderKind:**
```kotlin
enum class OrderKind(val displayName: String) {
    LIMIT("지정가"),
    MARKET("시장가")
}
```

### 4.2 MatchResult

```kotlin
data class MatchResult(
    val tradeId: String,          // UUID
    val buyOrderId: String,
    val sellOrderId: String,
    val buyUserId: String,
    val sellUserId: String,
    val stockId: String,
    val price: Long,              // 체결가
    val quantity: Long,           // 체결 수량
    val matchedAt: Instant
)
```

- 매칭 엔진이 생성하는 순수 VO
- Kafka `OrderMatchedEvent`로 변환하여 발행

---

## 5. 동시성 모델

### 5.1 종목별 단일 스레드

```
┌───────────────────────────────────────────────────┐
│                OrderBookManager                    │
│                                                    │
│  ConcurrentHashMap<String, OrderBook>              │
│                                                    │
│  "STOCK-001" ──▶ OrderBook (단일 스레드 접근)        │
│  "STOCK-002" ──▶ OrderBook (단일 스레드 접근)        │
│  "STOCK-003" ──▶ OrderBook (단일 스레드 접근)        │
│  ...                                               │
└───────────────────────────────────────────────────┘
```

**접근 방식:**
- `OrderBookManager`가 `ConcurrentHashMap<String, OrderBook>`으로 종목별 호가창 관리
- 동일 종목의 주문은 `synchronized(orderBook)` 또는 종목별 `ReentrantLock`으로 직렬화
- 서로 다른 종목은 완전 병렬 처리

**왜 단일 스레드인가:**
- 호가창은 TreeMap + List로 구성 → 스레드 안전하지 않음
- 매칭 과정에서 양쪽 주문의 잔량을 동시에 변경 → 원자적 연산 필요
- 종목별 격리이므로 종목 간 간섭 없음

### 5.2 비동기 후처리

매칭 결과(MatchResult)가 나오면:
1. **동기**: 주문 상태 DB 업데이트, 호가창 Redis 저장
2. **비동기 (Kafka)**: 체결 이벤트, 가격 변동 이벤트, 호가창 변동 이벤트

```kotlin
// CommandHandler 내부 (의사코드)
val matches = orderBookManager.placeOrder(stockId, entry, orderType, orderKind)

// 동기 처리
orderPersistencePort.updateStatus(orderId, newStatus, filledQuantity)
orderBookCachePort.saveSnapshot(stockId, snapshot)

// 비동기 이벤트 발행
matches.forEach { match ->
    tradingEventPort.publishOrderMatched(match.toEvent())
    tradingEventPort.publishPriceUpdated(stockId, match.price)
}
tradingEventPort.publishOrderBookUpdated(stockId, snapshot)
```

---

## 6. 잔고 관리

### 6.1 가용/동결 분리 모델

```
총 잔고 = 가용 잔고 + 동결 잔고

매수 주문 시:
  필요 금액 = price × quantity
  가용 잔고 -= 필요 금액
  동결 잔고 += 필요 금액

매도 주문 시:
  가용 주식 -= quantity
  동결 주식 += quantity

체결 시:
  매수자: 동결 잔고 -= 체결금액, 주식 += 체결수량
  매도자: 동결 주식 -= 체결수량, 잔고 += 체결금액

취소 시:
  매수: 동결 잔고 → 가용 잔고
  매도: 동결 주식 → 가용 주식
```

### 6.2 원자적 연산

- Redis(Redisson)의 `RAtomicLong` 또는 `RLock` 활용
- 혹은 PostgreSQL의 비관적 락 (`SELECT ... FOR UPDATE`)
- 잔고 부족 시 주문 거부 (ErrorCode: T001, T002)

> **Note**: 잔고/포트폴리오 도메인은 별도 구현 단계. 호가창 MVP에서는 잔고 검증 없이 주문을 받고, 후속 단계에서 잔고 연동.

---

## 7. Redis 호가창 영속화

### 7.1 저장 전략

```
목적: 서비스 재시작 시 호가창 복구
방식: 주문 단위 저장 + 주기적 스냅샷
```

### 7.2 Redis 키 구조

```
# 매수 호가 (Sorted Set - score: -price로 역순 정렬)
orderbook:{stockId}:bids → RScoredSortedSet<String(JSON)>
  score = -price (높은 가격이 먼저 오도록)
  member = OrderEntry JSON

# 매도 호가 (Sorted Set - score: price)
orderbook:{stockId}:asks → RScoredSortedSet<String(JSON)>
  score = price
  member = OrderEntry JSON

# 주문 인덱스 (Hash - 취소용)
orderbook:{stockId}:index → RMap<String(orderId), String(side:price)>

# 스냅샷 (최근 스냅샷 캐시)
orderbook:{stockId}:snapshot → RBucket<String(JSON)>
```

### 7.3 복구 프로세스

```
@PostConstruct (OrderBookManager 초기화)
1. 활성 종목 목록 조회 (stock-service 또는 DB)
2. 각 종목별 Redis에서 호가 데이터 로드
   ├─ bids Sorted Set → TreeMap 복원
   └─ asks Sorted Set → TreeMap 복원
3. 복구 실패 시 → 빈 호가창으로 시작 (로그 경고)
```

---

## 8. Kafka 이벤트

### 8.1 발행 이벤트 (trading-service → 외부)

| 토픽 | 이벤트 클래스 | 발행 시점 |
|------|-------------|----------|
| `order.matched` | `OrderMatchedEvent` | 매칭 체결 시 |
| `order.cancelled` | `OrderCancelledEvent` | 주문 취소 시 |
| `price.updated` | `PriceUpdatedEvent` | 체결로 가격 변동 시 |
| `orderbook.updated` | `OrderBookUpdatedEvent` | 호가창 변동 시 |

### 8.2 구독 이벤트 (외부 → trading-service)

| 토픽 | 이벤트 클래스 | 처리 |
|------|-------------|------|
| `schedule.trade` | `ScheduleTradeEvent` | NPC/기관 주문 접수 → PlaceOrderUseCase 호출 |

### 8.3 이벤트 클래스 (common 모듈 재사용)

모든 이벤트 클래스는 `common/event/DomainEvent.kt`에 정의되어 있음:
- `OrderMatchedEvent(tradeId, buyOrderId, sellOrderId, buyUserId, sellUserId, stockId, price, quantity)`
- `OrderCancelledEvent(orderId, userId, stockId, reason)`
- `PriceUpdatedEvent(stockId, previousPrice, currentPrice, changeRate, volume)`
- `OrderBookUpdatedEvent(stockId, bidOrders: List<OrderBookEntry>, askOrders: List<OrderBookEntry>)`
- `ScheduleTradeEvent(investorId, investorType, stockId, orderType, quantity, reason)`

> **참고**: common의 `OrderBookEntry(price, quantity, orderCount)`는 이벤트/API용 **집계** VO.
> domain의 `OrderEntry(orderId, userId, price, remainingQuantity, timestamp)`는 호가창 내부 **개별 주문** VO.

---

## 9. API 명세

### 9.1 호가창 조회

```
GET /api/trading/orderbook/{stockId}?depth=10
```

**Response:**
```json
{
  "success": true,
  "data": {
    "stockId": "STOCK-001",
    "bids": [
      { "price": 50000, "quantity": 150, "orderCount": 3 },
      { "price": 49950, "quantity": 80, "orderCount": 2 }
    ],
    "asks": [
      { "price": 50050, "quantity": 100, "orderCount": 2 },
      { "price": 50100, "quantity": 200, "orderCount": 5 }
    ],
    "bestBid": 50000,
    "bestAsk": 50050,
    "spread": 50,
    "timestamp": "2026-02-16T10:30:00Z"
  }
}
```

### 9.2 주문 접수

```
POST /api/trading/orders
```

**Request:**
```json
{
  "userId": "user-123",
  "stockId": "STOCK-001",
  "orderType": "BUY",
  "orderKind": "LIMIT",
  "price": 50000,
  "quantity": 10
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "orderId": "ord-uuid-xxx",
    "status": "PENDING",
    "orderType": "BUY",
    "orderKind": "LIMIT",
    "price": 50000,
    "quantity": 10,
    "filledQuantity": 5,
    "matches": [
      {
        "tradeId": "trd-uuid-xxx",
        "price": 50000,
        "quantity": 5,
        "counterpartyOrderId": "ord-uuid-yyy",
        "matchedAt": "2026-02-16T10:30:01Z"
      }
    ],
    "createdAt": "2026-02-16T10:30:01Z"
  }
}
```

### 9.3 주문 취소

```
DELETE /api/trading/orders/{orderId}?userId={userId}
```

**Response:**
```json
{
  "success": true,
  "message": "주문이 취소되었습니다"
}
```

---

## 10. 에러 처리

common 모듈의 `ErrorCode` 재사용:

| 코드 | 상수 | 메시지 | 상황 |
|------|------|--------|------|
| T001 | INSUFFICIENT_BALANCE | 잔액이 부족합니다 | 매수 금액 > 가용 잔고 |
| T002 | INSUFFICIENT_STOCK | 보유 수량이 부족합니다 | 매도 수량 > 가용 주식 |
| T003 | INVALID_ORDER_QUANTITY | 주문 수량이 유효하지 않습니다 | quantity ≤ 0 |
| T004 | INVALID_ORDER_PRICE | 주문 가격이 유효하지 않습니다 | 호가 단위 불일치 / 가격 제한 초과 |
| T005 | ORDER_NOT_FOUND | 주문을 찾을 수 없습니다 | 존재하지 않는 orderId |
| T006 | ORDER_ALREADY_CANCELLED | 이미 취소된 주문입니다 | 중복 취소 시도 |
| T007 | ORDER_ALREADY_MATCHED | 이미 체결된 주문입니다 | 체결 완료 주문 취소 시도 |
| S002 | MARKET_CLOSED | 장이 마감되었습니다 | 장외 시간 주문 |

---

## 11. 호가 단위 (Tick Size)

`PriceUtil.kt` 재사용:

| 주가 범위 | 호가 단위 |
|-----------|----------|
| ~ 1,000원 | 1원 |
| ~ 5,000원 | 5원 |
| ~ 10,000원 | 10원 |
| ~ 50,000원 | 50원 |
| ~ 100,000원 | 100원 |
| ~ 500,000원 | 500원 |
| 500,000원 ~ | 1,000원 |

지정가 주문 시 `PriceUtil.isValidPrice(price)` 검증 필수.

---

## 12. 복구 전략

### 12.1 서비스 재시작

```
1. OrderBookManager @PostConstruct
2. Redis에서 호가 데이터 로드 (OrderBookCachePort.loadEntries)
3. TreeMap 재구성
4. orderIndex 재구성
5. 정상 서비스 시작
```

### 12.2 Redis 장애

```
1. Redis 연결 실패 감지
2. 빈 호가창으로 시작 (WARN 로그)
3. DB에서 PENDING/PARTIALLY_FILLED 주문 조회
4. 호가창에 재등록
5. Redis 복구 시 스냅샷 동기화
```

### 12.3 데이터 정합성

```
호가창(in-memory) = Source of Truth (운영 중)
Redis = 영속화 백업 (주기적 동기화)
PostgreSQL = 주문 이력 (감사 추적)
```

- 매칭은 항상 in-memory에서 수행
- Redis는 복구용 백업
- 체결 결과는 PostgreSQL에 확정 기록

---

## 13. 아키텍처 계층 구조

Hexagonal Architecture (stock-service 패턴 준수):

```
trading-service/
└── src/main/kotlin/com/stocksimulator/tradingservice/
    ├── domain/
    │   ├── OrderModel.kt              # 주문 도메인 엔티티
    │   ├── OrderEntry.kt              # 호가창 내부 주문 VO
    │   ├── OrderBook.kt               # 호가창 매칭 엔진
    │   ├── MatchResult.kt             # 매칭 결과 VO
    │   ├── PriceLevel.kt              # 가격 레벨 집계 VO
    │   └── OrderBookSnapshot.kt       # 호가창 스냅샷
    │
    ├── application/
    │   ├── dto/
    │   │   ├── command/order/
    │   │   │   ├── PlaceOrderCommand.kt
    │   │   │   └── CancelOrderCommand.kt
    │   │   ├── query/order/
    │   │   │   └── OrderBookQuery.kt
    │   │   └── result/order/
    │   │       ├── OrderBookResult.kt
    │   │       └── PlaceOrderResult.kt
    │   ├── port/
    │   │   ├── in/order/
    │   │   │   ├── GetOrderBookUseCase.kt
    │   │   │   ├── PlaceOrderUseCase.kt
    │   │   │   └── CancelOrderUseCase.kt
    │   │   └── out/order/
    │   │       ├── OrderBookCachePort.kt
    │   │       ├── OrderPersistencePort.kt
    │   │       └── TradingEventPort.kt
    │   ├── service/
    │   │   └── OrderBookManager.kt     # 호가창 생명주기 관리
    │   └── handler/order/
    │       ├── OrderBookQueryHandler.kt
    │       └── OrderBookCommandHandler.kt
    │
    └── infrastructure/
        ├── config/
        │   └── RedissonConfig.kt
        └── adapter/
            ├── in/
            │   ├── web/
            │   │   ├── OrderBookWebAdapter.kt
            │   │   ├── HealthWebAdapter.kt
            │   │   └── dto/
            │   │       ├── OrderBookResponse.kt
            │   │       ├── PlaceOrderRequest.kt
            │   │       └── PlaceOrderResponse.kt
            │   └── event/
            │       └── TradingEventConsumer.kt
            └── out/
                ├── cache/
                │   └── RedisOrderBookCacheAdapter.kt
                ├── persistence/order/
                │   ├── entity/OrderJpaEntity.kt
                │   ├── repository/OrderJpaRepository.kt
                │   └── adapter/OrderPersistenceAdapter.kt
                └── event/
                    └── KafkaTradingEventPublisher.kt
```

---

## 14. 의존성 요약

### 14.1 common 모듈 재사용

| 구분 | 클래스/유틸 | 용도 |
|------|-----------|------|
| DTO | `OrderType`, `OrderStatus` | 주문 유형/상태 enum |
| DTO | `ApiResponse<T>` | REST 응답 래퍼 |
| Event | `OrderMatchedEvent`, `OrderCancelledEvent` 등 | Kafka 이벤트 |
| Event | `KafkaTopics` | 토픽 상수 |
| Event | `OrderBookEntry` | 호가창 집계 VO (이벤트용) |
| Util | `PriceUtil` | 호가 단위 검증, 가격 제한 |
| Util | `GameTimeUtil` | 장 시간 확인 |
| Exception | `ErrorCode` (T001~T008) | 거래 에러 코드 |
| Exception | `BusinessException` 계열 | 예외 클래스 |

### 14.2 인프라 의존성

| 인프라 | 용도 | 설정 |
|--------|------|------|
| PostgreSQL | 주문 이력 (trading 스키마) | `jdbc:postgresql://...:5432/stocksim?currentSchema=trading` |
| Redis/Redisson | 호가창 영속화, 캐시 | `redis://...:6379` |
| Kafka | 이벤트 발행/구독 | `...:9092` |
| Eureka | 서비스 디스커버리 | `http://eureka-server:8761/eureka/` |

---

## 15. 향후 확장

| 단계 | 기능 | 설명 |
|------|------|------|
| Phase 2 | 잔고/포트폴리오 | Balance, Portfolio 도메인 + 가용/동결 연산 |
| Phase 2 | WebSocket | 실시간 호가창/체결 정보 푸시 |
| Phase 3 | 가격 변동 엔진 | 체결 → 주가 변동 계산 (PriceUtil.calculatePriceImpact) |
| Phase 3 | 이벤트 반영 | EventOccurredEvent 수신 → 주가 변동 |
| Phase 4 | 랭킹 시스템 | 수익률/총자산/거래량 랭킹 |
| Phase 4 | 거래 내역 조회 | 체결 이력 조회 API |
